#include "PlayerManager.h"

SynthAudioSource::SynthAudioSource (MidiKeyboardState& keyState, const juce::String& sfzPath)
    : keyboardState (keyState)
{
    formatManager.registerBasicFormats();
    for (int i = 0; i < 128; ++i) {
        synth.addVoice(new sfzero::Voice());
    }

    loadFile(sfzPath);
}

void SynthAudioSource::loadFile(const juce::String& sfzPath)
{
    DBG("Loading " << sfzPath);
    synth.clearSounds();
    auto sfzFile = File(sfzPath);

    double loadProgress = 0;
    synth.clearSounds();

    if (!sfzFile.existsAsFile()) {
        return;
    }

    std::unique_ptr<sfzero::Sound> sound = nullptr;
    auto extension = sfzFile.getFileExtension();
    if ((extension == ".sf2") || (extension == ".SF2")) {
        sound = std::make_unique<sfzero::SF2Sound>(sfzFile);
    }
    else {
        sound = std::make_unique<sfzero::Sound>(sfzFile);
    }
    sound->loadRegions();
    sound->loadSamples(&formatManager, &loadProgress, nullptr);
    synth.addSound(sound.release());

    DBG("file loaded!");
}

void SynthAudioSource::prepareToPlay (int /*samplesPerBlockExpected*/, double sampleRate)
{
    midiCollector.reset (sampleRate);
    synth.setCurrentPlaybackSampleRate (sampleRate);
}

void SynthAudioSource::getNextAudioBlock (const AudioSourceChannelInfo& bufferToFill)
{
    // the synth always adds its output to the audio buffer, so we have to clear it
    // first..
    bufferToFill.clearActiveBufferRegion();

    // fill a midi buffer with incoming messages from the midi input.
    MidiBuffer incomingMidi;
    midiCollector.removeNextBlockOfMessages (incomingMidi, bufferToFill.numSamples);

    // pass these messages to the keyboard state so that it can update the component
    // to show on-screen which keys are being pressed on the physical midi keyboard.
    // This call will also add midi messages to the buffer which were generated by
    // the mouse-clicking on the on-screen keyboard.
    keyboardState.processNextMidiBuffer (incomingMidi, 0, bufferToFill.numSamples, true);

    // and now get the synth to process the midi events and generate its output.
    synth.renderNextBlock (*bufferToFill.buffer, incomingMidi, 0, bufferToFill.numSamples);
}

//==============================================================================

Callback::Callback (AudioSourcePlayer& playerIn)
    : player (playerIn) {}

void Callback::audioDeviceIOCallbackWithContext (const float* const* inputChannelData,
                                        int numInputChannels,
                                        float* const* outputChannelData,
                                        int numOutputChannels,
                                        int numSamples,
                                        const AudioIODeviceCallbackContext& context)
{
    player.audioDeviceIOCallbackWithContext (inputChannelData,
                                                numInputChannels,
                                                outputChannelData,
                                                numOutputChannels,
                                                numSamples,
                                                context);
}

void Callback::audioDeviceAboutToStart (AudioIODevice* device)
{
    player.audioDeviceAboutToStart (device);
}

void Callback::audioDeviceStopped()
{
    player.audioDeviceStopped();
}

//==============================================================================

PlayerManager::PlayerManager(const juce::String& sfzFile)
    : synthAudioSource(keyboardState, sfzFile),
      callback(audioSourcePlayer)
{
    audioSourcePlayer.setSource (&synthAudioSource);
    
    audioDeviceManager.addAudioCallback (&callback);
    audioDeviceManager.initialise (0, 2, nullptr, true, {}, nullptr);
    audioDeviceManager.addAudioCallback (&callback);

    auto devices = juce::MidiInput::getAvailableDevices();
    if (devices.isEmpty()) {
        DBG("There is no Midi keyboard input");
        audioDeviceManager.addMidiInputDeviceCallback({}, &(synthAudioSource.midiCollector));
    }
    else {
        for (auto dev : devices) {
            DBG("Midi input device: " << dev.name << ", " << dev.identifier);
            audioDeviceManager.setMidiInputDeviceEnabled(dev.name, true);
            audioDeviceManager.addMidiInputDeviceCallback(dev.identifier, &(synthAudioSource.midiCollector));
        }
    }
}

PlayerManager::~PlayerManager()
{
    audioSourcePlayer.setSource (nullptr);

    auto devices = juce::MidiInput::getAvailableDevices();
    if (devices.isEmpty()) {
        audioDeviceManager.removeMidiInputDeviceCallback({}, &(synthAudioSource.midiCollector));
    }
    else {
        for (auto dev : devices) {
            audioDeviceManager.removeMidiInputDeviceCallback(dev.identifier, &(synthAudioSource.midiCollector));
        }
    }

    audioDeviceManager.removeAudioCallback (&callback);
}