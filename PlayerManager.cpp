#include "PlayerManager.h"

using namespace juce;

SynthAudioSource::SynthAudioSource (MidiKeyboardState& keyState)
    : keyboardState (keyState)
{
    formatManager.registerBasicFormats();
}

void SynthAudioSource::loadFile(const juce::String filePath)
{
    std::cout << filePath << std::endl;
    auto ext = juce::File{filePath}.getFileExtension();

    if (ext.equalsIgnoreCase(".sfz") && sfzSynth.load(filePath)) {
        sfType = SoundFontType::sfz;
    }
    else if (ext.equalsIgnoreCase(".sf2") && sf2Synth.load(filePath)) {
        sfType = SoundFontType::sf2;
    }
}

void SynthAudioSource::prepareToPlay (int samplesPerBlockExpected, double sampleRate)
{
    midiCollector.reset (sampleRate);
    sfzSynth.prepareToPlay(samplesPerBlockExpected, sampleRate);
    std::cout << "prepareToPlay (samplesPerBlockExpected, sampleRate) = (" << samplesPerBlockExpected << ", " << sampleRate << ")" << std::endl;
}

void SynthAudioSource::getNextAudioBlock (const AudioSourceChannelInfo& bufferToFill)
{
    // the synth always adds its output to the audio buffer, so we have to clear it
    // first..
    bufferToFill.clearActiveBufferRegion();

    // fill a midi buffer with incoming messages from the midi input.
    MidiBuffer incomingMidi;
    midiCollector.removeNextBlockOfMessages (incomingMidi, bufferToFill.numSamples);

#if DISPLAY_GUI
    // pass these messages to the keyboard state so that it can update the component
    // to show on-screen which keys are being pressed on the physical midi keyboard.
    // This call will also add midi messages to the buffer which were generated by
    // the mouse-clicking on the on-screen keyboard.
    keyboardState.processNextMidiBuffer (incomingMidi, 0, bufferToFill.numSamples, true);
#endif

    // and now get the synth to process the midi events and generate its output.
    switch (sfType)
    {
    case SoundFontType::none:
        break;
    case SoundFontType::sf2:
        sf2Synth.playingMidi(incomingMidi);
        break;
    case SoundFontType::sfz:
        sfzSynth.playingMidi(incomingMidi);
        sfzSynth.renderBlock(bufferToFill.buffer->getWritePointer(0), bufferToFill.buffer->getWritePointer(1), bufferToFill.numSamples);
        break;
    default:
        break;
    }
}

//==============================================================================

Callback::Callback (AudioSourcePlayer& playerIn)
    : player (playerIn) {}

void Callback::audioDeviceIOCallbackWithContext (const float* const* inputChannelData,
                                        int numInputChannels,
                                        float* const* outputChannelData,
                                        int numOutputChannels,
                                        int numSamples,
                                        const AudioIODeviceCallbackContext& context)
{
    player.audioDeviceIOCallbackWithContext (inputChannelData,
                                                numInputChannels,
                                                outputChannelData,
                                                numOutputChannels,
                                                numSamples,
                                                context);
}

void Callback::audioDeviceAboutToStart (AudioIODevice* device)
{
    player.audioDeviceAboutToStart (device);
}

void Callback::audioDeviceStopped()
{
    player.audioDeviceStopped();
}

//==============================================================================

PlayerManager::PlayerManager(const juce::String& sfzFile)
    : synthAudioSource(keyboardState),
      callback(audioSourcePlayer)
{
    audioSourcePlayer.setSource (&synthAudioSource);
    
    audioDeviceManager.addAudioCallback (&callback);
    audioDeviceManager.initialise (0, 2, nullptr, true, {}, nullptr);
    audioDeviceManager.addAudioCallback (&callback);

    auto devices = juce::MidiInput::getAvailableDevices();
    if (devices.isEmpty()) {
        std::cout << "There is no Midi keyboard input\n";
        audioDeviceManager.addMidiInputDeviceCallback({}, &(synthAudioSource.midiCollector));
    }
    else {
        for (auto dev : devices) {
            std::cout << "Trying connect to midi input device: " << dev.identifier << std::endl;
            audioDeviceManager.setMidiInputDeviceEnabled(dev.identifier, true);
            audioDeviceManager.addMidiInputDeviceCallback(dev.identifier, &(synthAudioSource.midiCollector));
            std::cout << "  ====> " << dev.identifier << " is " << (audioDeviceManager.isMidiInputDeviceEnabled(dev.identifier) ? "enabled and connect successfully" : "disabled and connect failure") << std::endl;
        }
    }

    std::cout << std::flush;
    juce::Thread::launch([this, sfzFile]() { synthAudioSource.loadFile(sfzFile); });
}

PlayerManager::~PlayerManager()
{
    audioSourcePlayer.setSource (nullptr);

    auto devices = juce::MidiInput::getAvailableDevices();
    if (devices.isEmpty()) {
        audioDeviceManager.removeMidiInputDeviceCallback({}, &(synthAudioSource.midiCollector));
    }
    else {
        for (auto dev : devices) {
            audioDeviceManager.removeMidiInputDeviceCallback(dev.identifier, &(synthAudioSource.midiCollector));
        }
    }

    audioDeviceManager.removeAudioCallback (&callback);
}